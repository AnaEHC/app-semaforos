# --- IMPORTS ---
import streamlit as st
import pandas as pd
import io
import json
from datetime import datetime
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload, MediaIoBaseUpload
from google.oauth2 import service_account
from fpdf import FPDF

# --- CONFIGURACI√ìN INICIAL ---
st.set_page_config(page_title="App Sem√°foros Web + Closers", page_icon="üö¶", layout="wide")

# --- CONEXI√ìN GOOGLE DRIVE ---
SCOPES = ['https://www.googleapis.com/auth/drive']

# Leemos las credenciales desde los secretos de Streamlit
credentials_info = st.secrets["gcp_service_account"]
credentials = service_account.Credentials.from_service_account_info(credentials_info, scopes=SCOPES)

# Creamos el servicio de conexi√≥n a Drive
service = build('drive', 'v3', credentials=credentials)

# IDs de carpeta y base de datos
ID_CARPETA_PADRE = '1Sh2Pt_ZsKNrRz6GM6NbON0ICapYovCyS'
ID_BASE_ASIGNACIONES = '1XhxVi0YRCfZmeqEgKaJJo6SSbBq7UVgm'

# --- FUNCIONES AUXILIARES ---

def buscar_id_carpeta(nombre_carpeta):
    query = f"mimeType = 'application/vnd.google-apps.folder' and name = '{nombre_carpeta}' and '{ID_CARPETA_PADRE}' in parents"
    resultados = service.files().list(q=query, fields="files(id, name)").execute()
    archivos = resultados.get('files', [])
    return archivos[0]['id'] if archivos else None

def buscar_semaforo_en_carpeta(carpeta_id):
    query = (
        f"('{carpeta_id}' in parents) and "
        f"(mimeType='application/vnd.ms-excel.sheet.macroEnabled.12' or "
        f"mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') and "
        f"name contains 'SEMAFORO'"
    )
    resultados = service.files().list(q=query, fields="files(id, name)").execute()
    archivos = resultados.get('files', [])
    
    if archivos:
        return archivos[0]['id'], archivos[0]['name']
    else:
        return None, None




def crear_carpeta_closer(nombre_closer):
    nombre_carpeta = f"COMPARTIDO & {nombre_closer}"
    carpeta_id = buscar_id_carpeta(nombre_carpeta)
    if not carpeta_id:
        file_metadata = {'name': nombre_carpeta, 'mimeType': 'application/vnd.google-apps.folder', 'parents': [ID_CARPETA_PADRE]}
        carpeta = service.files().create(body=file_metadata, fields='id').execute()
        return carpeta.get('id')
    return carpeta_id

def mover_archivo_a_carpeta(nombre_closer, df_clientes):
    carpeta_id = crear_carpeta_closer(nombre_closer)
    excel_buffer = io.BytesIO()
    with pd.ExcelWriter(excel_buffer, engine='openpyxl') as writer:
        df_clientes.to_excel(writer, index=False)
    excel_buffer.seek(0)
    media = MediaIoBaseUpload(excel_buffer, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', resumable=True)
    service.files().create(body={'name': f"Asignaciones_{nombre_closer}.xlsx", 'parents': [carpeta_id]}, media_body=media, fields='id').execute()

def descargar_archivo(file_id):
    request = service.files().get_media(fileId=file_id)
    fh = io.BytesIO()
    downloader = MediaIoBaseDownload(fh, request)
    done = False
    while not done:
        status, done = downloader.next_chunk()
    fh.seek(0)
    return pd.read_excel(fh)

def descargar_base_asignaciones():
    try:
        request = service.files().get_media(fileId=ID_BASE_ASIGNACIONES)
        fh = io.BytesIO()
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while not done:
            status, done = downloader.next_chunk()
        fh.seek(0)
        return pd.read_excel(fh)
    except Exception:
        return pd.DataFrame()

def guardar_base_asignaciones(df):
    excel_buffer = io.BytesIO()
    with pd.ExcelWriter(excel_buffer, engine='openpyxl') as writer:
        df.to_excel(writer, index=False)
    excel_buffer.seek(0)
    media = MediaIoBaseUpload(excel_buffer, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', resumable=True)
    service.files().update(fileId=ID_BASE_ASIGNACIONES, media_body=media).execute()

def obtener_clientes_rojos():
    clientes_rojos_total = []

    for nombre_semaforo, nombre_carpeta in st.session_state['semaforos_carpetas'].items():
        carpeta_id = buscar_id_carpeta(nombre_carpeta)
        if carpeta_id:
            file_id, file_name = buscar_semaforo_en_carpeta(carpeta_id)
            if file_id:
                df_semaforo = descargar_archivo(file_id)
                if "SEMAFORO" in df_semaforo.columns:
                    semaforo_columna = df_semaforo["SEMAFORO"].astype(str).fillna("").str.upper()
                    df_rojos = df_semaforo[semaforo_columna == "ROJO"]
                    if not df_rojos.empty:
                        df_rojos["CALL"] = nombre_semaforo
                        clientes_rojos_total.append(df_rojos)

    if clientes_rojos_total:
        df_final = pd.concat(clientes_rojos_total, ignore_index=True)
        df_final["CLOSER ASIGNADO"] = ""  # ‚úÖ A√±adimos columna vac√≠a
        return df_final
    else:
        return pd.DataFrame()
def generar_pdf(df, nombre_archivo):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=8)

    # Ancho de cada columna (puedes ajustarlo)
    col_width = pdf.w / (len(df.columns) + 1)

    # Encabezados
    for col_name in df.columns:
        pdf.cell(col_width, 10, str(col_name), border=1)
    pdf.ln(10)

    # Filas
    for _, row in df.iterrows():
        for item in row:
            pdf.cell(col_width, 10, str(item), border=1)
        pdf.ln(10)

    pdf.output(nombre_archivo)



# --- CARGA INICIAL DE DATOS ---
if 'datos_cargados' not in st.session_state:
    st.session_state['semaforos_carpetas'] = {
        "SEMAFORO ELCHE 2.0": "COMPARTIDO ELCHE 2.0",
        "SEMAFORO ELCHE 3.0": "COMPARTIDO ELCHE 3.0",
        "SEMAFORO ELCHE 4.0": "COMPARTIDO ELCHE 4.0",
        "SEMAFORO VIGO 1.0": "COMPARTIDO VIGO 1.0",
        "SEMAFORO VIGO 2.0": "COMPARTIDO VIGO 2.0",
        "SEMAFORO VIGO 3.0": "COMPARTIDO VIGO 3.0",
        "SEMAFORO LEON 1.0": "COMPARTIDO LEON 1.0"
    }
    st.session_state['clientes_rojos'] = obtener_clientes_rojos()  # üöÄ CORREGIDO AQU√ç
    st.session_state['seguimiento'] = descargar_base_asignaciones()  # üöÄ CORREGIDO AQU√ç
    st.session_state['datos_cargados'] = True


# --- MEN√ö LATERAL ---
st.sidebar.title("üö¶ Men√∫ Principal")
opcion = st.sidebar.radio("Ir a:", ("üè† Inicio", "üìÇ Sem√°foros Comerciales", "üéØ Asignar Closers", "üìã Seguimiento de Asignaciones", "üìñ Manual de Usuario"))

# --- CONTENIDO SEG√öN PESTA√ëA ---

if opcion == "üè† Inicio":
    st.title("üö¶ Bienvenido a la App de Sem√°foros Web")
    st.success("¬°Del contacto, al cierre! üöÄ")

# --- SECCI√ìN SEM√ÅFOROS COMERCIALES ---
elif opcion == "üìÇ Sem√°foros Comerciales":
    st.title("üìÇ Sem√°foros Comerciales")
    
    # ‚ö° Cambiado para usar bien el session_state
    semaforos_carpetas = st.session_state['semaforos_carpetas']
    
    semaforo_elegido = st.selectbox(
        "Selecciona un Sem√°foro:",
        list(semaforos_carpetas.keys())
    )
    
    carpeta_nombre = semaforos_carpetas[semaforo_elegido]
    carpeta_id = buscar_id_carpeta(carpeta_nombre)

    if carpeta_id:
        with st.spinner('‚è≥ Descargando sem√°foro...'):
            file_id, file_name = buscar_semaforo_en_carpeta(carpeta_id)
            if file_id:
                df_semaforo = descargar_archivo(file_id)
                st.dataframe(df_semaforo, use_container_width=True)
            else:
                st.warning(f"‚ö†Ô∏è No se encontr√≥ archivo SEM√ÅFORO en {carpeta_nombre}.")
    else:
        st.warning(f"‚ö†Ô∏è No se encontr√≥ carpeta {carpeta_nombre}.")

# --- SECCI√ìN ASIGNAR CLOSERS ---
# --- SECCI√ìN ASIGNAR CLOSERS ---
elif opcion == "üéØ Asignar Closers":
    st.title("üéØ Asignar Closers")

    # üîÑ Bot√≥n para actualizar clientes rojos
    if st.button("üîÑ Actualizar clientes rojos"):
        with st.spinner('‚è≥ Actualizando clientes rojos...'):
            st.session_state['clientes_rojos'] = obtener_clientes_rojos()
            st.success("‚úÖ Clientes rojos actualizados correctamente.")
            st.rerun()

    if 'clientes_rojos' not in st.session_state:
        st.session_state['clientes_rojos'] = obtener_clientes_rojos()

    clientes_rojos = st.session_state['clientes_rojos']

    if clientes_rojos.empty:
        st.info("‚ÑπÔ∏è No hay clientes ROJOS pendientes.")
    else:
        edited_df = st.data_editor(
            clientes_rojos,
            use_container_width=True,
            num_rows="fixed",
        )

        if st.button("‚úÖ Asignar Clientes"):
            with st.spinner('‚è≥ Asignando clientes...'):
                nuevas_asignaciones = []
                closers_creados = {}  # üî• Creamos un diccionario para los nuevos closers

                for _, row in edited_df.iterrows():
                    closer = str(row["CLOSER ASIGNADO"]).strip()
                    if closer:
                        nueva = row.to_dict()
                        nueva["CLOSER"] = closer
                        nueva["ESTADO"] = ""
                        nuevas_asignaciones.append(nueva)

                        # üî• Agrupamos por Closer
                        if closer not in closers_creados:
                            closers_creados[closer] = []
                        closers_creados[closer].append(nueva)

                if nuevas_asignaciones:
                    # üî• Guardar nuevas asignaciones en la base
                    df_nuevas = pd.DataFrame(nuevas_asignaciones)
                    df_existente = descargar_base_asignaciones()
                    df_final = pd.concat([df_existente, df_nuevas], ignore_index=True)
                    guardar_base_asignaciones(df_final)

                    # üî• Crear carpetas de cada Closer y subir su archivo
                    for closer, clientes in closers_creados.items():
                        mover_archivo_a_carpeta(closer, pd.DataFrame(clientes))

                    # üî• Actualizar clientes rojos (solo los no asignados)
                    clientes_restantes = edited_df[edited_df["CLOSER ASIGNADO"].astype(str).str.strip() == ""]
                    st.session_state['clientes_rojos'] = clientes_restantes

                    st.success("‚úÖ Clientes asignados y archivos de Closers creados correctamente.")
                    st.rerun()
                else:
                    st.warning("‚ö†Ô∏è No has asignado ning√∫n Closer.")



# --- SECCI√ìN SEGUIMIENTO DE ASIGNACIONES ---
elif opcion == "üìã Seguimiento de Asignaciones":
    st.title("üìã Seguimiento de Asignaciones")

    seguimiento = descargar_base_asignaciones()

    if seguimiento.empty:
        st.info("‚ÑπÔ∏è No hay asignaciones registradas todav√≠a.")
    else:
        # üî• Convertimos columnas importantes a texto
        if "ESTADO" in seguimiento.columns:
            seguimiento["ESTADO"] = seguimiento["ESTADO"].astype(str)
        if "CLOSER" in seguimiento.columns:
            seguimiento["CLOSER"] = seguimiento["CLOSER"].astype(str)

        # üìç Checkbox para mostrar solo asignaciones activas
        mostrar_pendientes = st.checkbox("üëÄ Mostrar solo asignaciones activas", value=True)

        # üî• Si marcaron mostrar solo activas, filtramos
        if mostrar_pendientes:
            seguimiento = seguimiento[seguimiento["ESTADO"].str.upper() != "FINALIZADO"]

        # üî• Contamos el n√∫mero de asignaciones activas
        num_activas = len(seguimiento)

        # üî• Mostramos contador bonito
        st.info(f"üë• Asignaciones activas: **{num_activas}**")

        # üî• Editor de datos
        edited_df = st.data_editor(
            seguimiento,
            column_order=[
                "selected", "CALL", "COMERCIAL", "CLIENTE", "D√çA",
                "F2025", "F2026", "HL", "VIGILANCIA",
                "IMPLANT", "DENUNCIAS", "SEMAFORO",
                "NOTAS", "CLOSER", "ESTADO"
            ],
            use_container_width=True,
            num_rows="fixed",  # No dejar crear filas nuevas
            column_config={
                "ESTADO": st.column_config.SelectboxColumn(
                    "ESTADO",
                    help="Selecciona o escribe otro estado",
                    options=["", "FINALIZADO", "PASA CENTRAL"],
                    required=False,
                ),
                "CLOSER": st.column_config.TextColumn(
                    "CLOSER",
                    help="Escribe el nombre del closer",
                    required=False,
                )
            }
        )

        col1, col2 = st.columns([1, 1])

        with col1:
            if st.button("üíæ Guardar cambios"):
                with st.spinner('‚è≥ Guardando asignaciones...'):
                    df_guardar = edited_df.copy()

                    # Aseguramos que todas las columnas necesarias existen
                    columnas_necesarias = [
                        "CALL", "COMERCIAL", "CLIENTE", "D√çA", "F2025", "F2026",
                        "HL", "VIGILANCIA", "IMPLANT", "DENUNCIAS", "SEMAFORO",
                        "NOTAS", "CLOSER", "ESTADO"
                    ]
                    for col in columnas_necesarias:
                        if col not in df_guardar.columns:
                            df_guardar[col] = ""

                    df_guardar["selected"] = False  # Reset columna seleccionados

                    st.session_state['seguimiento'] = df_guardar
                    guardar_base_asignaciones(df_guardar)

                    st.success("‚úÖ Asignaciones guardadas correctamente.")
                    st.rerun()

        with col2:
            if st.button("‚¨áÔ∏è¬øQuireres un Informe PDF?"):
                with st.spinner('‚è≥ Generando PDF...'):
                    nombre_pdf = "seguimiento_asignaciones.pdf"
                    df_para_pdf = edited_df.drop(columns=["selected"])
                    generar_pdf(df_para_pdf, nombre_pdf)
                    with open(nombre_pdf, "rb") as file:
                        st.download_button("Descargarlo aqu√≠", file, file_name=nombre_pdf)


elif opcion == "üìñ Manual de Usuario":
    st.title("üìñ Manual de Usuario üöÄ")
    st.write("Bienvenido/a a la gu√≠a r√°pida de uso de la App de Sem√°foros Web + Closers.")

    st.divider()

    st.header("üè† Inicio")
    st.markdown("""
    - Aqu√≠ puedes ver el resumen general de la aplicaci√≥n.
    - Es la pantalla principal desde donde partes para usar las otras secciones.
    """)

    st.divider()

    st.header("üìÇ Sem√°foros Comerciales")
    st.markdown("""
    - Consulta el estado de los clientes en cada Sem√°foro.
    - **Rojo üî¥:** Cliente en riesgo / no trabajado.
    - **Amarillo üü°:** Cliente en seguimiento.
    - **Verde üü¢:** Cliente trabajado y estable.
    - **Azul üîµ:** Cliente cerrado o no interesado.
    """)

    st.divider()

    st.header("üéØ Asignar Closers")
    st.markdown("""
    - Asigna manualmente un **Closer** a cada cliente ROJO pendiente.
    - Pasos:
      1. Escribe el nombre del **Closer** en la columna "CLOSER ASIGNADO".
      2. Pulsa el bot√≥n ‚úÖ **Asignar Clientes**.
      3. Los clientes asignados desaparecer√°n de esta lista y pasar√°n al seguimiento.

    - Cada Closer recibir√° autom√°ticamente su archivo de asignaciones üìÑ.
    """)

    st.divider()

    st.header("üìã Seguimiento de Asignaciones")
    st.markdown("""
    - Aqu√≠ puedes hacer seguimiento de los clientes asignados:
      - Selecciona de la columna **ESTADO** en el desplegable la opci√≥n correcta.
      - Filtrar con el checkbox üëÄ **"Mostrar solo asignaciones activas"**.
      - Guardar los cambios pulsando **üíæ Guardar cambios**.
      - Descargar el listado en PDF pulsando **‚¨áÔ∏è Descargar PDF**.

    - **Nota:** Un cliente marcado como **FINALIZADO** dejar√° de mostrarse si tienes activo el filtro.
    """)

    st.divider()

    st.header("üõ†Ô∏è Consejos y Buenas Pr√°cticas")
    st.markdown("""
    - Trabaja en modo **pantalla completa** para mejor experiencia.
    - Antes de asignar un Closer, aseg√∫rate de escribir bien el nombre.
    - Usa siempre los botones de la app, **no borres nada manualmente** desde Drive.
    - Guarda cambios cada vez que hagas modificaciones grandes.
    - Al terminar tus asignaciones, descarga el PDF como respaldo.

    > üì¢ **Importante:** La app no borra datos de Drive autom√°ticamente. Siempre puedes recuperar informaci√≥n en el hist√≥rico si la necesitas.
    """)

    st.divider()

    st.success("¬°Ahora est√°s listo/a para trabajar a toda m√°quina! üöÄ")

